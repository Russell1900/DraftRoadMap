# 数据结构

## 数据

数据：计算机可操作的对象的集合。（人们）

数据元素：每个数据的实例。（每个人）

数据项：可以理解成数据元素的属性。（组成人的属性，胳膊腿等）

数据对象：性质相同的数据元素的集合，是数据的子集。

数据结构：是相互之间存在特定关系的数据集合。

### 结构

逻辑结构：指数据对象中元素之间的关系，是针对不同问题建立的结构。结合，线性，树型，图型。

物理结构：数据在计算机中的储存结构。顺序储存，链式储存

### 抽象数据结构

数据类型：指一组性质相同的值的集合以及定义在茨基河上的一些操作总称。

抽象数据类型：指一个数学模型及定义在其上的一组操作。

### 算法特性：

* 输入输出：算法中至少有一个输入和输出

* 有穷性：指算法在执行完有限步骤后自动退出而不会无限循环，并在可接受时间内完成。

* 确定性：每个步骤都有具体确定的含义。

* 可行性：每个步骤都是可行的。

### 设计要求:

* 正确性: 至少能够正确的解决问题.（没有语法错，对合法输入返回正确结构，对非法输入，产生说明等。通过测试）
* 可读性：
* 健壮性：当输入不合法是也会处理得当。
* 时间效率高，储存量低：

### 算法度量方法：

* 事后统计方法：指通过设计好的测试程序和数据，利用计算机对不同算法测试，并进行时间比较。（效率低，基本可以舍去）
* 事前统计方法：在计算机程序编制前，一句计算方法估算时间。

函数上界：存在正整数N和整数C使得任取n>=N, g(n)<Cf(n), 则称f是g的上界，g是f的下界。g=O(f)。g/f=C（n->无穷）

严格上界：对任意正数C，都存在正整数N，使得g(n)<Cf(n), 曾称f是g的严格上界，g=o(f), g/f=0(n->无穷)

最坏情况/平均情况。

...



## 串

串是一种特殊的线性表，其经常需要连续访问串中的元素，如字符串。其储存与链表的区别是，在每个节点会储存多个元素，然后再加入下一个节点的地址，这样提高了空间利用率。

### KMP 算法

ＫＭＰ算法的思想：

当在主串S中查找子串T时，一般是通过将S和T中的元素（S[i], T[j]）逐一比较，KMP算法希望不回溯i，只回溯j，而且j不会到子串开始的位置，而是回到一个特定的位置，也就是当S[i]!=T[j]时，回到next[j],将S[i]与next[j]比较，若不相同则继续回溯到next[next[j]]，直到与s[i]与子串第一个元素比较之后，仍不相同则i++，j指向第一个元素，开始比较。

在确定next时，采用递归法，将子串从i开始和子串j比较，依次递归出next的值。

```c
//确定next
int get_next(char* T, int len, int* next){
    int i=0,j=-1;
    next[0] = -1;//初始值为0，当j为0时，T[i]!=T[j],则j=-1，此时i向后进发，next[i++]=0
    while(i<len){
        if(j==-1||T[i]==T[j]){ //当i，j相等时，确定next[i++]
            i++;
            j++;
            next[i] = j;
        }else{
            j=next[j];
        }
    }
    return 1;
}

int index_KMP(char* S, int len1, char* T, int len2, int pos){
    int next[255];
    int i, j;
    memset(next,0,sizeof(next));
    get_next(T, len2, next);
    i=pos;
    j=0;
    while(i<len1&&j<len2){
        if(S[i]==T[j]){
            i++;
            j++;
        }else{
            j=next[j];
        }
    }
    if(j==len2){
        return i-len2;
    }else{
        return 0;
    }
}
```

## 树
数中的每个元素的值是不能重复的，只有一个根节点。

* Degree: 数中节点的子树数成为节点的度
* sibling：同一节点的子树成为兄弟。
* 层level：根节点为第一层，往下+1
* 高height：从一个节点到叶节点的最大路长+1

### 二叉树

每个节点至多有两个子树的树叫做二叉树。

* 满二叉树，高为k的二叉树且有2^k^-1个节点。

* 完全二叉树：高为k的二叉树且：

  1.所有叶节点都出现在k层或k-1层

  2.k-1层的所有叶节点都在非叶节点的右侧

  3.除k-1层的最右侧非叶节点可能只有左分支或两分支外，其他非叶节点均需要有两个子分支。

二叉树性质：

* i层中至多有2^(i-1)^个元素
* 高位i的树最多有2^i^-1个元素
* n~0~=n~2~+1，n~0~为叶节点数，n~2~为有两个分支的节点数（从总结点数和总链接数关系可得）。
* 有n个元素的完全二叉树拥有的层数为[log~2~n]+1 （包括完全二叉树）。
* 对于完全二叉树，可以按层从左到右将节点编号。
  1. 除根节点外，切他节点的父节点为[i/2]
  2. 若i>n/2, 则节点无左子节点（对于标准二叉树，也可理解为无子节点，为叶节点）。若i<=n/2，左子节点编号为2i
  3. 若i>(n-1)/2，则节点无右子节点（意为当n为偶数时，会且仅会出现一个只有左分支的节点，编号为n/2）。其他右节点为2i+1

顺序储存结构只适用于完全二叉树。一般的二叉树使用链式储存。

### 霍夫曼树：

将每个叶节点附上权重，求出总权值最小的数。权重{w~i~}~n~,叶节点距离{d~i~}~n~,求树使sum(w~i~d~i~)~n~最小。

方法：根据不等式方程，若w~i~, d~i~为升序，则sum(w~i~d~n-i~)~n~<=sum(w~i~d~i~)~n~

将w从小到大排序，取两个最小的节点，做为新树K~1~的子节点，较小的为左节点，新树K~1~权重为自己点权重之和，将w集合中两子节点删除，加入K~1~，继续重复步骤直到集合中只有一颗树。

霍夫曼编码：

计算数据个单元重复出现的次数，作为权重，生成霍夫曼树，元素数据为原编码。此时将之前的数据单元替换成霍夫曼树的路径（从根节点开始，左0右1），一次可以减少数据长度，但需要将节点编码和霍夫曼树提供给解码方。



## 图

### 最小生成树：

#### prim算法：

```c
/* prim算法首先建立v和e两个数组。v数组长度为顶点数，最后输出信息为该节点的链接的节点。e为储存的信息为已经遍历过的节点中，到第i个节点距离最小的节点号。最小生成树有n个节点和n-1条边。
过程：
1.初始化v和e，v中都设为0，e为算有顶点到0的权重.（0->0=0，不连通为INF）
2.查找距离当前顶点（初始时为0）最近的点，记为k，v[k]=0（表示0和k建立链路），e[k]=0（表示k已加入树中，下面将不再对k查找）
3.以k为当前节点，计算k到其他节点（除e[j]==0外）的权重，如果比上一个值小则存入e[j]，v[j]=k。（这样e中保留的是对顶点j的最下权重，v[j]则是对应的顶点）
4.重复2-3 n-1次（顶点个数为n，去掉0）。
5.此时e中应该均为0，除非有为联通的顶点，所以此算法应该在图的联通分量中进行。v中储存i顶点对应的联通顶点值。
prin产生的最小生成树不一定是二叉树。
/*
```

